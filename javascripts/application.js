
// Generated by CoffeeScript 1.4.0
(function() {
  var $, util;

  util = {
    data: function(_self, key, value_callback) {
      var cache;
      cache = _self.data(key);
      if (cache == null) {
        cache = value_callback.call(_self);
        _self.data(key, cache);
      }
      return cache;
    },
    unempty: function(obj) {
      return (obj != null) && !/^\s+$/.test(obj);
    },
    scroll: function() {
      return {
        w: $(document.body)[0].scrollWidth,
        h: $(document.body)[0].scrollHeight
      };
    },
    offset: function(source, target, arrow) {
      this.source = arguments[0].offset();
      this.source.w = arguments[0].outerWidth();
      this.source.h = arguments[0].outerHeight();
      this.target = {
        w: arguments[1].width(),
        h: arguments[1].height(),
        outer: {
          w: arguments[1].outerWidth(),
          h: arguments[1].outerHeight()
        }
      };
      this.target.padding = {
        w: this.target.outer.w - this.target.w,
        h: this.target.outer.h - this.target.h
      };
      this.arrow_size = arguments[2];
      this.scroll = util.scroll();
      if (arguments.length >= 4) {
        this.content = {
          w: arguments[3].outerWidth(),
          h: arguments[3].outerHeight()
        };
        this.target.outer.w = this.content.w + this.target.padding.w;
        this.target.outer.h = this.content.h + this.target.padding.h;
      }
      return this;
    }
  };

  util.offset.prototype = {
    arrow: function(pos) {
      var border, ret;
      ret = {
        left: 0,
        top: 0,
        position: "absolute"
      };
      border = 1;
      switch (pos) {
        case "left":
          ret.left = this.source.left - this.arrow_size - border;
          ret.top = this.source.top + this.source.h / 2;
          break;
        case "right":
          ret.left = this.source.left + this.source.w + this.arrow_size + border;
          ret.top = this.source.top + this.source.h / 2;
          break;
        case "top":
          ret.left = this.source.left + this.source.w / 2;
          ret.top = this.source.top - this.arrow_size - border;
          break;
        case "bottom":
          ret.top = this.source.top + this.source.h + this.arrow_size + border;
          ret.left = this.source.left + this.source.w / 2;
      }
      return ret;
    },
    auto: function() {
      var h, w, w1;
      h = this.source.top / (this.scroll.h - this.source.top);
      w = this.source.left / (this.scroll.w - this.source.left);
      w1 = this.scroll.w - this.source.left;
      if (this.source.left > 0) {
        w1 = w1 / this.source.left;
      }
      if (h > w) {
        if (h > w1) {
          return "top";
        } else {
          return "right";
        }
      } else {
        if (h > w1) {
          return "left";
        } else {
          return "bottom";
        }
      }
    },
    center: function() {
      var ret;
      ret = {
        top: 0,
        left: 0
      };
      if (this.scroll.h > this.target.outer.h) {
        ret.top = (this.scroll.h - this.target.outer.h) / 2;
      }
      if (this.scroll.w > this.target.outer.w) {
        ret.left = (this.scroll.w - this.target.outer.w) / 2;
      }
      return this._wrap_result(ret);
    },
    top: function() {
      var ret;
      ret = {
        top: this.source.top - this.target.outer.h - this.arrow_size
      };
      return this._top_bottom(ret);
    },
    bottom: function() {
      var ret;
      ret = {
        top: this.source.top + this.source.h + this.arrow_size
      };
      return this._top_bottom(ret);
    },
    left: function() {
      var ret;
      ret = {
        left: this.source.left - this.target.outer.w - this.arrow_size
      };
      return this._left_right(ret);
    },
    right: function() {
      var ret;
      ret = {
        left: this.source.left + this.source.w + this.arrow_size
      };
      return this._left_right(ret);
    },
    _left_right: function(opt) {
      var muti;
      opt.top = this.source.top + this.source.h / 2 - this.target.outer.h / 2;
      muti = opt.top + this.target.outer.h - this.scroll.h;
      if (opt.top < 0) {
        opt.top = 0;
      } else if (muti > 0) {
        opt.top -= muti;
      }
      return this._wrap_result(opt);
    },
    _top_bottom: function(opt) {
      var muti;
      opt.left = this.source.left + this.source.w / 2 - this.target.outer.w / 2;
      muti = opt.left + this.target.outer.w - this.scroll.w;
      if (opt.left < 0) {
        opt.left = 0;
      } else if (muti > 0) {
        opt.left -= muti;
      }
      return this._wrap_result(opt);
    },
    _wrap_result: function(opt) {
      opt.w = this.target.w;
      opt.h = this.target.h;
      if (this.content != null) {
        opt.w = this.content.w;
        opt.h = this.content.h;
      }
      opt.position = "absolute";
      return opt;
    }
  };

  window.util = util;

  $ = jQuery;

  $.fn.wrapData = function(key, callback) {
    return util.data(this, key, callback);
  };

  $.fn.outerHtml = function() {
    return $('<div>').append(this.eq(0).clone().show()).html();
  };

  $.fn.rebind = function(event_name, func) {
    return this.unbind(event_name).bind(event_name, func);
  };

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var $, cache_objects, _popup;

  $ = jQuery;

  cache_objects = [];

  _popup = function(self, option) {
    $.extend(this, option);
    this.self = $(self);
    return this;
  };

  _popup.prototype = {
    toggle: function() {
      if (this.self.is(this.except)) {
        return;
      }
      if (!this.self.hasClass('active')) {
        this.show();
        this.self.addClass('active');
      } else {
        this.hide();
        this.self.removeClass('active');
      }
      return this;
    },
    show: function() {
      var offset, temp_offset;
      this.body = this.get_content();
      offset = new util.offset(this.self, this.body, this.offset);
      temp_offset = offset[this.direction]();
      if (this.direction === "auto") {
        this.direction = temp_offset;
        temp_offset = offset[temp_offset]();
      } else {
        temp_offset;

      }
      $('#' + this.arrow_doc_id).addClass(this.direction).css(offset.arrow(this.direction));
      return this.body.css(temp_offset).show();
    },
    hide: function() {
      if (this.is_remove_if_hide) {
        this.body.remove();
      } else {
        this.body.hide();
      }
      return $('#' + this.arrow_doc_id).remove();
    },
    get_content: function() {
      var href, is_remove_if_hide;
      href = this.self.attr('href');
      if (typeof this.content === "function") {
        return this.content();
      } else if (typeof this.content === "object" && (this.content != null)) {
        return this.content;
      } else if ((href != null) && href.length > 1 && href[0] === "#") {
        is_remove_if_hide = true;
        return $(href);
      } else {
        return this.default_content();
      }
    },
    default_content: function() {
      var content, title;
      title = this.self.attr('data-title');
      content = this.self.attr('data-content');
      if (title != null) {
        title = "<div class=\"header\">" + title + "</div>";
      } else {
        title = "";
      }
      content = $("<div style=\"display: none; max-width: " + this.max_width + "\">\n  <div class=\"popup border\">\n    " + title + "\n    <div class=\"body\">\n      " + content + "\n    </div>\n  </div>\n</div>");
      $(document.body).append("<div id=\"" + this.arrow_doc_id + "\" class=\"" + this.arrow_doc_class + "\"></div>");
      content.appendTo(document.body);
      return content;
    }
  };

  $.fn.popup = function(option) {
    var binder;
    option = $.extend({}, $.fn.popup.defaults, option || {});
    binder = option.live ? "live" : "bind";
    return this[binder](option.trigger_name(), function() {
      var p;
      p = $(this).wrapData(option.cache_key_suffix, function() {
        return new _popup(this, option);
      });
      cache_objects.push(p);
      p.toggle();
      return false;
    });
  };

  $.fn.popup.defaults = {
    cache_key_suffix: "popup",
    direction: "auto",
    live: false,
    trigger: "click",
    offset: 0,
    except: '.disabled,:disabled,:animated',
    content: null,
    is_remove_if_hide: true,
    arrow_doc_id: "js-arrow-popup",
    arrow_doc_class: "arrow-popup",
    max_width: "660px",
    trigger_name: function() {
      return this.trigger + "." + this.cache_key_suffix;
    },
    after: {
      show: function() {},
      hide: function() {}
    }
  };

  $.fn.popup.constructor = _popup;

  $(document).on('click', function() {
    $.each(cache_objects, function(index, ele) {
      return ele.toggle();
    });
    return cache_objects = [];
  });

  /*
  $ = jQuery
  
  
  _popup = (self, option) ->
    $.extend(@, option)
    @self = $(self)
    @target = @_target()
    @target.appendTo(document.body)
  
    # bind event
    # binder = if @live then "live" else "bind"
    # @self[binder](@trigger+".popup", (event)=> @toggle(event))
  
    # target old offset
    to_offset = new util.offset(@self, @target, @arrow)
    @to_os = @_target_offset(to_offset)
    @to_os.width = @to_os.w
    @to_os.height = @to_os.h
    @to_os.overflow = 'hidden'
    @to_os.opacity = 0
  
    @
  
  _popup:: =
    toggle: ->
      return false if @target.is(@except) or @target.find('.popup-box').is(@except)
  
      @content = @_content()
      # bind html hide
      $(document).rebind 'click.popup', (event)=> @hide(true)
  
  
      # target new offset(contain content)
      tn_offset = new util.offset(@self, @target, @arrow, @content)
      @tn_os = @_target_offset(tn_offset)
      @tn_os.width = @tn_os.w
      @tn_os.height = @tn_os.h
      @tn_os.opacity = 1
  
      # arrow
      @tn_arrow = tn_offset.arrow(@position)
  
      # is or not target bind date self
      @isself = if @target.data('bind_data')? then @target.data('bind_data').is(@self) else true
      if @target.css('display') is 'none' or !@isself
        @show()
      else
        @hide()
      false
    show: ->
      @after.show.call(@self)
      tc_before = left: 0, top: 0
      tc_after = opacity: 1, top: 0
  
      switch @position
        when "left", "center"
          tc_before.left = @tn_os.width
          tc_after.left = 0
        when "right"
          tc_before.left = -@tn_os.width
          tc_after.left = 0
        when "top"
          tc_before.top = @tn_os.height
          tc_after.top = 0
        when "bottom"
          tc_before.top = -@tn_os.height
          tc_after.top = 0
  
      # is self
      if @isself
        @target.css(@to_os)
        $('.popup-arrow').css(@tn_arrow)
      else
        @hide()
  
      $('.popup-arrow').addClass(@position).show().animate(@tn_arrow)
      @target.show().animate(@tn_os,
        => 
          @target.find('.popup-box').css(tc_before)
          .html(@content.outerHtml()).animate(tc_after,
            => @target.css({overflow: 'visible'})))
  
      @target.data('bind_data', @self)
  
    # flag is or not self
    hide: (flag)->
      # return if @target.css('display') == 'none'
      if flag
        $(document).off 'click.popup'
  
      @after.hide.call(if @isself or flag then @self else @target.data('bind_data'))
      tc = opacity: 0
      switch @position
        when "left", "center"
          tc.left = @tn_os.width
        when "right"
          tc.left = -@tn_os.width
        when "top"
          tc.top = @tn_os.height
        when "bottom"
          tc.top = -@tn_os.height
  
      @target.css({overflow: 'hidden'}).find('.popup-box').animate(tc,
        => 
          if @isself or flag 
            $('.popup-arrow').removeClass(@position).hide()
            @target.animate(@to_os, => @target.hide()))
  
      @target.data('bind_data', null)
  
    _target_offset: (util_offset)->
      t_os = util_offset[@position]()
      # if position is auto to cal 
      if @position is 'auto'
        @position = t_os
        t_os = util_offset[@position]()
      t_os
    _target: ->
      t = $('.popup-box-outer')
      unless t[0]?
        t = $(@template) 
        $(document.body).append('<div class="popup-arrow"></div>')
      t
    _content: ->
      $(@self.attr('href'))
  
  $.fn.popup = (option) ->
    option = $.extend({}, $.fn.popup.defaults, option || {})
    binder = if option.live then "live" else "bind"
    @[binder] option.trigger + ".popup", -> 
      $(@).wrapData('popup', -> new _popup(@, option)).toggle()
  
    @
  
  $.fn.popup.defaults =
    position: "auto" # center left top right bottom
    live: false
    trigger: "click"
    arrow: 20
    duration: 1000
    except: ':animated'
    template: """<div class="popup-box-outer">
        <div class="popup-box"></div>
      </div>
      """
    after: 
      show: -> @addClass('actived')
      hide: -> @removeClass('actived')
  
  
  # bind html hide
  $(document).on 'click.popupouter', '.popup-box-outer',
    (event)-> 
      event.stopPropagation()
  */


}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var $, get_tip, _tip;

  $ = jQuery;

  get_tip = function(_self, option) {
    return $(_self).wrapData(option.cache_key_suffix, function() {
      return new _tip(_self, option);
    });
  };

  _tip = function(_self, option) {
    $.extend(this, option);
    this.self = $(_self);
    return this;
  };

  _tip.prototype = $.extend({}, $.fn.popup.constructor.prototype, {});

  $.fn.tip = function(option) {
    var binder, eventin, eventout;
    option = $.extend({}, $.fn.tip.defaults, option || {});
    binder = option.live ? "live" : "bind";
    eventin = option.trigger === "hover" ? "mouseenter" : "foucs";
    eventout = option.trigger === "hover" ? "mouseleave" : "blur";
    if (option.trigger.indexOf("click")) {
      this[binder](option.trigger_name(), function() {
        get_tip(this, option).toggle();
        return false;
      });
    } else {
      this[binder](eventin, function() {
        get_tip(this, option).toggle();
        return false;
      })[binder](eventout, function() {
        get_tip(this, option).toggle();
        return false;
      });
    }
    return this;
  };

  $.fn.tip.defaults = $.extend({}, $.fn.popup.defaults, {
    cache_key_suffix: "tip",
    offset: 8,
    is_remove_if_hide: true,
    trigger: "hover",
    arrow_doc_id: "js-arrow-tip",
    arrow_doc_class: "arrow-tip",
    max_width: "260px",
    content: function() {
      var content, title;
      title = this.self.attr('data-title');
      content = $("<div style=\"display: none; max-width: " + this.max_width + "\">\n  <div class=\"tip\">\n    " + title + "\n  </div>\n</div>");
      $(document.body).append("<div id=\"" + this.arrow_doc_id + "\" class=\"" + this.arrow_doc_class + "\"></div>");
      content.appendTo(document.body);
      return content;
    }
  });

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var $, cache_objects, _menu;

  $ = jQuery;

  cache_objects = [];

  _menu = function(_self, option) {
    $.extend(this, option);
    this.self = $(_self);
    this.active = this.self;
    if (this.self.parent().is('li')) {
      this.active = this.self.parent();
    }
    return this;
  };

  _menu.prototype = {
    toggle: function() {
      if (this.self.is(this.except)) {
        return false;
      }
      if (this.active.hasClass('active')) {
        this.hide();
      } else {
        this.show();
      }
      return false;
    },
    show: function() {
      var scroll_h, source_padding, source_t, top;
      this.body = this.get_content();
      source_t = this.self.offset().top;
      scroll_h = util.scroll().h;
      source_padding = (this.self.parent().outerHeight() - this.self.outerHeight()) / 2;
      top = this.self.outerHeight() + source_padding;
      if (scroll_h / 2 < source_t) {
        top -= this.body.outerHeight(true) + this.self.outerHeight();
      }
      this.body.css({
        top: top
      }).show();
      return this.active.addClass('active');
    },
    hide: function() {
      this.body.hide();
      return this.active.removeClass('active');
    },
    get_content: function() {
      return this.self.next();
    }
  };

  $.fn.menu = function(option) {
    var binder;
    option = $.extend({}, $.fn.menu.defaults, option || {});
    binder = option.live ? "live" : "bind";
    this[binder](option.trigger_name(), function(event) {
      var p;
      p = $(this).wrapData(option.cache_key_suffix, function() {
        return new _menu(this, option);
      });
      cache_objects.push(p);
      p.toggle();
      return false;
    });
    return this;
  };

  $.fn.menu.defaults = $.extend({}, $.fn.popup.defaults, {
    cache_key_suffix: "menu",
    direction: "auto"
  });

  $(document).on('click.menu', function() {
    return $.each(cache_objects, function(index, ele) {
      return ele.hide();
    });
  });

}).call(this);
// Generated by CoffeeScript 1.4.0
(function() {
  var $, _form;

  $ = jQuery;

  _form = function(_self, option) {
    $.extend(this, option);
    this.self = $(_self);
    return this;
  };

  _form.prototype = {
    go: function() {
      var data, k, self_title, url, v,
        _this = this;
      this.form_tag = this.self.closest('form');
      if (this.self.is(this.except)) {
        return;
      }
      this.before.call(this.self);
      self_title = this.self.text().replace(/(\r|\n|\r\n|\s)+/g, '');
      this.self.addClass('disabled');
      this.self.html(this.self.html().replace(self_title, "&bull;&bull;&bull;"));
      url = this.url();
      data = this.fields();
      for (k in data) {
        v = data[k];
        console.log(k, '=>', v);
      }
      $.ajaxSetup({
        beforeSend: function(xhr) {
          var token;
          token = $('meta[name=csrf-token]').attr('content');
          if (token != null) {
            return xhr.setRequestHeader('X-CSRF-Token', token);
          }
        }
      });
      $.post(url, data, function(msg) {
        return _this.post_after(self_title, msg);
      }).error(function(msg) {
        return _this.post_after(self_title, msg);
      });
      return false;
    },
    post_after: function(self_title, msg) {
      this.self.removeClass('disabled');
      this.self.html(self_title);
      return this.after.call(this.self, msg);
    },
    fields: function() {
      var data;
      data = {};
      this.field(data, 'input:hidden');
      this.field(data, 'input:text');
      this.field(data, 'input[type=email]');
      this.field(data, 'input[type=password]');
      this.field(data, 'select');
      this.field(data, 'input:radio:checked');
      this.field(data, 'textarea');
      this.field(data, 'input:checkbox:checked');
      return data;
    },
    field: function(data, selector) {
      $(selector, this.form_tag).each(function() {
        if (util.unempty(this.name)) {
          if (data[this.name] != null) {
            return data[this.name] += ',' + $(this).val();
          } else {
            return data[this.name] = $(this).val();
          }
        }
      });
      return data;
    },
    url: function() {
      return this.form_tag.attr('action') + this.url_suffix;
    }
  };

  $.fn.form = function(option) {
    var binder;
    option = $.extend({}, $.fn.form.defaults, option || {});
    binder = option.live ? "live" : "bind";
    this[binder](option.trigger_name(), function() {
      return $(this).wrapData(option.cache_key_suffix, function() {
        return new _form(this, option);
      }).go();
    });
    return this;
  };

  $.fn.form.defaults = {
    cache_key_suffix: "form",
    live: false,
    trigger: 'click',
    except: ".active",
    url_suffix: ".json",
    trigger_name: function() {
      return this.trigger + "." + this.cache_key_suffix;
    },
    after: function() {},
    before: function() {}
  };

}).call(this);
